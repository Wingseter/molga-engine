#include "ScriptCompiler.h"
#include "../Core/Project.h"
#include <filesystem>
#include <fstream>
#include <sstream>
#include <iostream>
#include <array>
#include <cstdio>

namespace fs = std::filesystem;

ScriptCompiler& ScriptCompiler::Get() {
    static ScriptCompiler instance;
    return instance;
}

void ScriptCompiler::SetProjectPath(const std::string& path) {
    projectPath = path;
    scriptsPath = (fs::path(path) / "Scripts").string();
    buildPath = (fs::path(path) / "Scripts" / "build").string();
}

std::vector<ScriptInfo> ScriptCompiler::DiscoverScripts() const {
    std::vector<ScriptInfo> scripts;

    if (scriptsPath.empty() || !fs::exists(scriptsPath)) {
        return scripts;
    }

    try {
        for (const auto& entry : fs::directory_iterator(scriptsPath)) {
            if (!entry.is_regular_file()) continue;

            std::string ext = entry.path().extension().string();
            if (ext != ".h" && ext != ".hpp") continue;

            // Check if corresponding .cpp exists
            std::string baseName = entry.path().stem().string();
            fs::path cppPath = fs::path(scriptsPath) / (baseName + ".cpp");

            if (fs::exists(cppPath)) {
                ScriptInfo info;
                info.name = baseName;
                info.headerPath = entry.path().string();
                info.sourcePath = cppPath.string();
                info.lastModified = std::max(
                    fs::last_write_time(entry.path()).time_since_epoch().count(),
                    fs::last_write_time(cppPath).time_since_epoch().count()
                );
                scripts.push_back(info);
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "[ScriptCompiler] Error discovering scripts: " << e.what() << std::endl;
    }

    return scripts;
}

bool ScriptCompiler::HasScriptsChanged() const {
    auto currentScripts = DiscoverScripts();

    // Check if count changed
    if (currentScripts.size() != cachedScripts.size()) {
        cachedScripts = currentScripts;
        return true;
    }

    // Check if any file was modified
    for (size_t i = 0; i < currentScripts.size(); ++i) {
        bool found = false;
        for (const auto& cached : cachedScripts) {
            if (cached.name == currentScripts[i].name) {
                found = true;
                if (cached.lastModified != currentScripts[i].lastModified) {
                    cachedScripts = currentScripts;
                    return true;
                }
                break;
            }
        }
        if (!found) {
            cachedScripts = currentScripts;
            return true;
        }
    }

    return false;
}

bool ScriptCompiler::GenerateCMakeLists() {
    auto scripts = DiscoverScripts();

    // Create build directory
    try {
        fs::create_directories(buildPath);
    } catch (const std::exception& e) {
        lastError = "Failed to create build directory: " + std::string(e.what());
        return false;
    }

    // Generate CMakeLists.txt
    std::string cmakeContent = GenerateCMakeContent(scripts);
    fs::path cmakePath = fs::path(scriptsPath) / "CMakeLists.txt";

    std::ofstream cmakeFile(cmakePath);
    if (!cmakeFile.is_open()) {
        lastError = "Failed to create CMakeLists.txt";
        return false;
    }
    cmakeFile << cmakeContent;
    cmakeFile.close();

    // Generate ScriptExports.cpp
    std::string exportsContent = GenerateScriptExportsContent(scripts);
    fs::path exportsPath = fs::path(scriptsPath) / "ScriptExports.cpp";

    std::ofstream exportsFile(exportsPath);
    if (!exportsFile.is_open()) {
        lastError = "Failed to create ScriptExports.cpp";
        return false;
    }
    exportsFile << exportsContent;
    exportsFile.close();

    std::cout << "[ScriptCompiler] Generated CMakeLists.txt and ScriptExports.cpp" << std::endl;
    return true;
}

std::string ScriptCompiler::GenerateCMakeContent(const std::vector<ScriptInfo>& scripts) {
    std::stringstream ss;

    ss << "# Auto-generated by Molga Engine - DO NOT EDIT MANUALLY\n";
    ss << "cmake_minimum_required(VERSION 3.16)\n";
    ss << "project(UserScripts)\n\n";

    ss << "set(CMAKE_CXX_STANDARD 17)\n";
    ss << "set(CMAKE_CXX_STANDARD_REQUIRED ON)\n";
    ss << "set(CMAKE_POSITION_INDEPENDENT_CODE ON)\n\n";

    // Engine include path
    ss << "# Engine include paths\n";
    if (!enginePath.empty()) {
        ss << "set(MOLGA_ENGINE_PATH \"" << enginePath << "\")\n";
        ss << "include_directories(${MOLGA_ENGINE_PATH}/src)\n";
        ss << "include_directories(${MOLGA_ENGINE_PATH}/external/glm)\n";
        ss << "include_directories(${MOLGA_ENGINE_PATH}/external/imgui)\n";
        ss << "include_directories(${MOLGA_ENGINE_PATH}/external/nlohmann_json/include)\n";
    }
    ss << "\n";

    // Add definition for editor mode (for OnInspectorGUI)
    ss << "add_definitions(-DMOLGA_EDITOR)\n\n";

    // Source files
    ss << "# Script source files\n";
    ss << "set(SCRIPT_SOURCES\n";
    ss << "    ScriptExports.cpp\n";
    for (const auto& script : scripts) {
        ss << "    " << script.name << ".cpp\n";
    }
    ss << ")\n\n";

    // Create shared library
    ss << "# Build as shared library\n";
    ss << "add_library(UserScripts SHARED ${SCRIPT_SOURCES})\n\n";

    // Platform-specific settings
    ss << "# Platform-specific output\n";
    ss << "if(APPLE)\n";
    ss << "    set_target_properties(UserScripts PROPERTIES\n";
    ss << "        SUFFIX \".dylib\"\n";
    ss << "        INSTALL_RPATH \"@loader_path\"\n";
    ss << "    )\n";
    ss << "elseif(WIN32)\n";
    ss << "    set_target_properties(UserScripts PROPERTIES SUFFIX \".dll\")\n";
    ss << "else()\n";
    ss << "    set_target_properties(UserScripts PROPERTIES SUFFIX \".so\")\n";
    ss << "endif()\n";

    return ss.str();
}

std::string ScriptCompiler::GenerateScriptExportsContent(const std::vector<ScriptInfo>& scripts) {
    std::stringstream ss;

    ss << "// Auto-generated by Molga Engine - DO NOT EDIT MANUALLY\n";
    ss << "// This file is regenerated when scripts are compiled\n\n";

    // Include all script headers
    for (const auto& script : scripts) {
        ss << "#include \"" << script.name << ".h\"\n";
    }

    ss << "\n";
    ss << "// Entry point called when library is loaded\n";
    ss << "extern \"C\" {\n";
    ss << "    void RegisterScripts() {\n";
    ss << "        // Scripts auto-register via REGISTER_SCRIPT macro\n";
    ss << "    }\n";
    ss << "}\n";

    return ss.str();
}

bool ScriptCompiler::Compile() {
    if (scriptsPath.empty()) {
        lastError = "Project path not set";
        return false;
    }

    // First generate/update CMakeLists.txt
    if (!GenerateCMakeLists()) {
        return false;
    }

    isCompiling = true;
    compileOutput.clear();
    lastError.clear();

    std::string output;

    // Run CMake configure
    std::string configureCmd = "cd \"" + scriptsPath + "\" && cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug 2>&1";
    int configResult = ExecuteCommand(configureCmd, output) ? 0 : -1;
    compileOutput += "=== CMake Configure ===\n" + output + "\n";

    if (configResult != 0 && output.find("error") != std::string::npos) {
        lastError = "CMake configuration failed";
        isCompiling = false;
        return false;
    }

    output.clear();

    // Run CMake build
    std::string buildCmd = "cd \"" + scriptsPath + "\" && cmake --build build 2>&1";
    bool buildResult = ExecuteCommand(buildCmd, output);
    compileOutput += "=== CMake Build ===\n" + output + "\n";

    isCompiling = false;

    if (!buildResult || output.find("error:") != std::string::npos) {
        lastError = "Build failed. Check compile output for details.";
        return false;
    }

    std::cout << "[ScriptCompiler] Scripts compiled successfully" << std::endl;
    return true;
}

bool ScriptCompiler::CreateScriptTemplate(const std::string& scriptName) {
    if (scriptsPath.empty()) {
        lastError = "Project path not set";
        return false;
    }

    // Create Scripts directory if it doesn't exist
    try {
        fs::create_directories(scriptsPath);
    } catch (const std::exception& e) {
        lastError = "Failed to create Scripts directory: " + std::string(e.what());
        return false;
    }

    // Check if files already exist
    fs::path headerPath = fs::path(scriptsPath) / (scriptName + ".h");
    fs::path sourcePath = fs::path(scriptsPath) / (scriptName + ".cpp");

    if (fs::exists(headerPath) || fs::exists(sourcePath)) {
        lastError = "Script '" + scriptName + "' already exists";
        return false;
    }

    // Generate header file
    std::string headerContent = GenerateHeaderTemplate(scriptName);
    std::ofstream headerFile(headerPath);
    if (!headerFile.is_open()) {
        lastError = "Failed to create header file";
        return false;
    }
    headerFile << headerContent;
    headerFile.close();

    // Generate source file
    std::string sourceContent = GenerateSourceTemplate(scriptName);
    std::ofstream sourceFile(sourcePath);
    if (!sourceFile.is_open()) {
        lastError = "Failed to create source file";
        return false;
    }
    sourceFile << sourceContent;
    sourceFile.close();

    std::cout << "[ScriptCompiler] Created script template: " << scriptName << std::endl;
    return true;
}

std::string ScriptCompiler::GenerateHeaderTemplate(const std::string& className) {
    std::string upperName = className;
    for (char& c : upperName) c = toupper(c);

    std::stringstream ss;

    ss << "#ifndef " << upperName << "_H\n";
    ss << "#define " << upperName << "_H\n\n";

    ss << "#include <Scripting/Script.h>\n";
    ss << "#include <Scripting/ScriptManager.h>\n\n";

    ss << "class " << className << " : public Script {\n";
    ss << "public:\n";
    ss << "    SCRIPT_CLASS(" << className << ")\n\n";

    ss << "    // Called once when the script is first enabled\n";
    ss << "    void Start() override;\n\n";

    ss << "    // Called every frame\n";
    ss << "    void Update(float deltaTime) override;\n\n";

    ss << "    // Inspector-visible properties\n";
    ss << "    float speed = 100.0f;\n\n";

    ss << "#ifdef MOLGA_EDITOR\n";
    ss << "    void OnInspectorGUI() override;\n";
    ss << "#endif\n";

    ss << "};\n\n";

    ss << "REGISTER_SCRIPT(" << className << ")\n\n";

    ss << "#endif // " << upperName << "_H\n";

    return ss.str();
}

std::string ScriptCompiler::GenerateSourceTemplate(const std::string& className) {
    std::stringstream ss;

    ss << "#include \"" << className << ".h\"\n";
    ss << "#include <ECS/Components/Transform.h>\n\n";

    ss << "#ifdef MOLGA_EDITOR\n";
    ss << "#include <imgui.h>\n";
    ss << "#endif\n\n";

    ss << "void " << className << "::Start() {\n";
    ss << "    // Initialization code here\n";
    ss << "}\n\n";

    ss << "void " << className << "::Update(float deltaTime) {\n";
    ss << "    Transform* transform = GetTransform();\n";
    ss << "    if (!transform) return;\n\n";
    ss << "    // Update logic here\n";
    ss << "    // Example: move right\n";
    ss << "    // float x, y;\n";
    ss << "    // transform->GetPosition(x, y);\n";
    ss << "    // transform->SetPosition(x + speed * deltaTime, y);\n";
    ss << "}\n\n";

    ss << "#ifdef MOLGA_EDITOR\n";
    ss << "void " << className << "::OnInspectorGUI() {\n";
    ss << "    ImGui::DragFloat(\"Speed\", &speed, 1.0f, 0.0f, 500.0f);\n";
    ss << "}\n";
    ss << "#endif\n";

    return ss.str();
}

std::string ScriptCompiler::GetCompiledLibraryPath() const {
    if (buildPath.empty()) return "";

#ifdef __APPLE__
    return (fs::path(buildPath) / "libUserScripts.dylib").string();
#elif defined(_WIN32)
    return (fs::path(buildPath) / "UserScripts.dll").string();
#else
    return (fs::path(buildPath) / "libUserScripts.so").string();
#endif
}

std::string ScriptCompiler::GetEngineIncludePath() const {
    if (enginePath.empty()) return "";
    return (fs::path(enginePath) / "src").string();
}

bool ScriptCompiler::ExecuteCommand(const std::string& command, std::string& output) {
    output.clear();

#ifdef _WIN32
    FILE* pipe = _popen(command.c_str(), "r");
#else
    FILE* pipe = popen(command.c_str(), "r");
#endif

    if (!pipe) {
        output = "Failed to execute command";
        return false;
    }

    std::array<char, 256> buffer;
    while (fgets(buffer.data(), buffer.size(), pipe) != nullptr) {
        output += buffer.data();
    }

#ifdef _WIN32
    int result = _pclose(pipe);
#else
    int result = pclose(pipe);
#endif

    return result == 0;
}
